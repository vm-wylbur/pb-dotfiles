" Preamble {{{
" Author: [Patrick Ball](mailto://pball@hrdag.org)
" (c) 2017 [HRDAG](https://hrdag.org), GPL-2 or later
" moved to github at vm-wylbur/pb-dotfiles
" git@github.com:vm-wylbur/pb-dotfiles.git
" install by symlinking to ~/.vimrc
" }}}
" todo: {{{
" * where is F being remapped? not ok!
" * open_file_under_cursor
" * leader stuff
" * add machinename to status line
" * indenting in vimrc?
" }}}
" setup {{{
set nocompatible
filetype plugin on
set directory^=$HOME/.backups//
" set shell=/bin/bash\ -ic
set shell=/bin/bash\ -l
set shellcmdflag=-ic
" }}}
" leader {{{
let mapleader = ','
nnoremap <leader>w :w <CR>
nnoremap <leader>e :ll <CR>
nnoremap <leader>m :marks <CR>       " go w single-quote '
" nnoremap <leader>r :registers <CR>   " access w double-quote "
nnoremap <leader>f :browse oldfiles <CR>
" this doesn't work but it's in the right direction
" nnoremap <leader>r :lcd %:p:h<CR>:Dispatch! run <CR>

nnoremap <leader>b :ls<CR>:b<Space>
nnoremap <leader>o :MBEOpen<CR>
nnoremap <leader>c :MBEClose<CR>
nnoremap <leader>t :MBEToggle<CR>
" nnoremap <leader>b :tab sball <CR>   " moves all buffers to tabs
nnoremap <leader>1 :b1<CR>
nnoremap <leader>2 :b2 <CR>
nnoremap <leader>3 :b3 <CR>
nnoremap <leader>4 :b4 <CR>
nnoremap <leader>5 :b5 <CR>
nnoremap <leader>6 :b6 <CR>
nnoremap <leader>7 :b7 <CR>
nnoremap <leader>8 :b8 <CR>
nnoremap <leader>9 :b9 <CR>

" }}}
" general remaps {{{
map <C-K> <C-W>k<C-W>_
map <C-H> <C-W>h<C-W>_
map <C-L> <C-W>l<C-W>_
map <C-J> <C-W>j<C-W>_
" select last paste in visual mode
nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'

" abbreviations for quick datestamping in Insert mode
iab xsdate <c-r>=strftime("%Y-%m-%dT%H:%M%Z")<CR>
iab xldate <c-r>=strftime("%a %d %b %Y %H:%M:%S%Z")<CR>

" }}}
" Python {{{
let python_highlight_all = 1
au FileType python syn keyword pythonDecorator True None False self
au FileType python map <buffer> F :set foldmethod=indent<cr>
au FileType python set cindent
au FileType python set cinkeys-=0#
au FileType python set indentkeys-=0#
" }}}
" Auto commands at save {{{
set omnifunc=syntaxcomplete#Complete
set autoread
augroup autoSaveAndRead
    autocmd!
    autocmd TextChanged,InsertLeave,FocusLost * silent! wall
    autocmd CursorHold * silent! checktime
augroup END
autocmd BufWritePre * :%s/\s\+$//e  " removes training whitespace
" }}}
" Plug {{{
call plug#begin('~/.vim/plugged')
Plug 'tpope/vim-sensible'
Plug 'itchyny/lightline.vim'
Plug 'vim-syntastic/syntastic'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-dispatch'
Plug 'ervandew/supertab'
Plug 'reedes/vim-pencil'
Plug 'kien/ctrlp.vim'
" Plug 'fholgado/minibufexpl.vim'
Plug 'ap/vim-buftabline'
Plug 'tpope/vim-obsession'
Plug 'altercation/vim-colors-solarized'
" Plug 'haya14busa/incsearch.vim'  " seems to work sporadically
call plug#end()
" }}}
" initialize plugins {{{
let g:pencil#wrapModeDefault = 'soft'   " default is 'hard'
augroup pencil
    autocmd!
    autocmd FileType markdown,mkd  call pencil#init()
    autocmd FileType text          call pencil#init()
augroup END
autocmd FileType markdown,mkd setlocal spell
let g:buftabline_numbers=1
let g:buftabline_indicators='on' " this is helpful.
let g:buftabline_separators='on'

" the C-TAB fails bc iTerm owns that (switches tabs)
" needs a keystroke.
" noremap <C-TAB>   :MBEbf<CR>
" let g:wintabs_switchbuf='useopen'
" noremap <C-b>   :MBEbf<CR>
" noremap <C-S-TAB> :MBEbb<CR>
" doesn't really work?
" nnoremap z/  <Plug>(incsearch-forward)
" nnoremap z?  <Plug>(incsearch-backward)

" }}}
" syntastic {{{
let g:syntastic_python_checkers=['pep8']
"let g:syntastic_python_checkers=['flake8']
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1

let g:syntastic_always_populate_loc_list = 0
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
" }}}
" status line {{{
set laststatus=2
" todo: shorten mode name
" this was stolen from someone, can't remember whom
let g:lightline = {
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [ ['mode', 'paste'],
        \             ['readonly', 'fullpath', 'modified'] ],
        \   'right': [ [ 'lineinfo' ], ['percent'], ['filetype'] ]
        \ },
        \ 'component': {
        \   'readonly': '%{&filetype=="help"?"":&readonly?"ðŸ”’ ":""}',
        \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
        \   'fullpath': '%F'
        \ },
	\'component_function': {
	\    'mode' :  'MyMode',
	\    'filetype' : 'MyFiletype'
	\ },
        \ 'component_visible_condition': {
        \   'readonly': '(&filetype!="help"&& &readonly)',
        \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))'
        \ },
        \ 'separator': { 'left': ' ', 'right': ' ' },
        \ 'subseparator': { 'left': ' ', 'right': ' ' }
        \ }
        let g:lightline.mode_map = {
            \ 'n'      : ' N ',
            \ 'i'      : ' I ',
            \ 'R'      : ' R ',
            \ 'v'      : ' V ',
            \ 'V'      : 'V-L',
            \ 'c'      : ' C ',
            \ "\<C-v>" : 'V-B',
            \ 's'      : ' S ',
            \ 'S'      : 'S-L',
            \ "\<C-s>" : 'S-B',
            \ '?'      : '      ' }

        function! MyMode()
            let fname = expand('%:t')
            return fname == '__Tagbar__' ? 'Tagbar' :
                    \ fname == 'ControlP' ? 'CtrlP' :
                    \ winwidth('.') > 60 ? lightline#mode() : ''
        endfunction
        function! MyFiletype()
            return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

" }}}
" visual interface: colors, cursors, numbering {{{
set relativenumber
set number
set noshowmode
syntax enable
set background=dark
colorscheme solarized
set guifont=Monaco:h14
" nnoremap <C-h> :set number! relativenumber! <CR>
" sets diff cursors for modes
let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_SR = "\<Esc>]50;CursorShape=2\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

augroup BgHighlight
    autocmd!
    autocmd WinEnter * set cul
    autocmd WinLeave * set nocul
augroup END


" automatically leave insert mode after 'updatetime' milliseconds of inaction
au CursorHoldI * stopinsert

" }}}
" whitespace vis {{{
" highlight Conceal guibg=NONE ctermbg=NONE ctermfg=DarkGrey
" autocmd BufWinEnter,BufReadPre * setlocal conceallevel=2 concealcursor=nv
" autocmd BufWinEnter,BufReadPre * syn match LeadingSpace /\(^ *\)\@<= / containedin=ALL conceal cchar=Â·
" set list listchars=tab:â†’\ ,eol:Â¬
set list listchars=tab:â†’\ ,
" " }}}
" Folding {{{
set foldenable
set foldlevelstart=10
set foldnestmax=10
nnoremap <space> za
set foldmethod=indent
" }}}
" functions {{{
" If buffer modified, update any 'Last modified: ' in the first 20 lines.
" 'Last modified: ' can have up to 10 characters before (they are retained).
" Restores cursor and window position using save_cursor variable.
function! LastModified()
  if &modified
    let save_cursor = getpos(".")
    let n = min([20, line("$")])
    keepjumps exe '1,' . n . 's#^\(.\{,10}Last modified: \).*#\1' .
          \ strftime('%a %d %b %Y %H:%M%Z') . '#e'
    call histdel('search', -1)
    call setpos('.', save_cursor)
  endif
endfun
autocmd BufWritePre * call LastModified()

command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
function! s:RunShellCommand(cmdline)
  echo a:cmdline
  let expanded_cmdline = a:cmdline
  for part in split(a:cmdline, ' ')
     if part[0] =~ '\v[%#<]'
        let expanded_part = fnameescape(expand(part))
        let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
     endif
  endfor
  botright new
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  call setline(1, 'You entered:    ' . a:cmdline)
  call setline(2, 'Expanded Form:  ' .expanded_cmdline)
  call setline(3,substitute(getline(2),'.','=','g'))
  execute '$read !'. expanded_cmdline
  setlocal nomodifiable
  1
endfunction

" }}}
set modelines=1
" vim:foldmethod=marker:foldlevel=0
