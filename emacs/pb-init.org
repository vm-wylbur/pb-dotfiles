# -*- mode: org -*-
# -*- coding: utf-8 -*-
#+TITLE: PB's Emacs configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showall
#+STARTUP: logdone
#+PROPERTY:  eval yes
#+PROPERTY: header-args :results silent
#+SETUPFILE: /Users/pball/src/org-html-themes/setup/theme-bigblow-local.setup

* Introduction
** About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>


This is an effort to write a literate elisp init file. I'm mostly following [[http://pages.sachachua.com/.emacs.d/Sacha.html%5D%5D%20amazing%20work.%20%0A%0A*%20Introduction][Sacha Chua's]] amazing work.

Writing this file in org-mode allows me to export it as html (which
happens automagically on GitHub), and to mix my thinking with the
code. This is another step toward [[http://reproducibleresearch.net][reproducible research]], close to
[[https://hrdag.org][HRDAG]]'s "principled data processing" ideas.

** paths and =use-package=

#+begin_src emacs-lisp :results output silent
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
(setq exec-path (append exec-path '("/usr/local/bin")))

(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
(package-initialize)
(add-to-list 'load-path "~/.emacs.d/elpa")

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
(require 'diminish)                ;; if you use :diminish
(require 'bind-key)                ;;
(use-package hydra)
#+end_src


* Basic Behaviors
** Theme
#+begin_src emacs-lisp
(use-package color-theme
  :ensure t)
(setq custom-safe-themes t)
(use-package zenburn-theme
  :ensure t
  :diminish ""
  :config
  (load-theme 'zenburn))
#+end_src
** elscreen
#+begin_src emacs-lisp
  (use-package elscreen
    :init
    (progn
      (elscreen-start)))
(defhydra hydra-elscreen (:color red :hint nil)
         "
elscreen
_0_ _c_reate    _n_ext     _s_tore
_1_ _k_ill      _p_revious _r_estore
_2_ _C_lone     _g_oto
_3_
_4_"
         ("0" elscreen-jump-0)
	 ("1" elscreen-jump-0)
	 ("2" elscreen-jump-0)
	 ("3" elscreen-jump-0)
	 ("4" elscreen-jump-0)
         ("c" elscreen-create)
         ("C" elscreen-clone)
         ("k" elscreen-kill)
         ("n" elscreen-next)
         ("p" elscreen-previous)
         ("s" elscreen-store)
         ("r" elscreen-restore)
         ("g" elscreen-goto)
         )
#+end_src

#+end_src

** Little UI bits
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
(show-paren-mode 1)
(tool-bar-mode -1)
(menu-bar-mode t)
(setq show-paren-delay 0)
(setq column-number-mode 1
      inhibit-startup-message t)
(setq-default cursor-type 'bar)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
(fringe-mode '(8 . 2))
#+end_src
** fill-column-indicator
This is broken, and I don't know why.
#+begin_src emacs-lisp
  ;; (use-package fill-column-indicator
  ;;   :diminish ""
  ;;   :ensure t
  ;;   :defer t
  ;;   :init (progn (
  ;;     (hook-into-modes 'fci-mode '(prog-mode-hook))
  ;;   (setq
  ;;     fci-rule-width 1
  ;;     fci-rule-color "darkblue"
  ;;     fci-rule-column 79))))

#+end_src
** Backups
#+begin_src emacs-lisp
(setq
 backup-directory-alist '(("." . "~/.emacs.d/backups"))
 delete-old-versions -1
 version-control t
 vc-make-backup-files t
 auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+end_src

** History
#+begin_src emacs-lisp
(setq
 savehist-file "~/.emacs.d/savehist"
 history-length t
 history-delete-duplicates t
 savehist-save-minibuffer-history 1
 savehist-additional-variables
 '(kill-ring
   search-ring
   regexp-search-ring))
(savehist-mode 1)
(desktop-save-mode 1)
#+end_src

** UTF-8
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

** minor editing hacks
  #+begin_src emacs-lisp :eval yes
(delete-selection-mode 1)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(show-paren-mode 1)
(bind-keys*
  ("M-n" . forward-paragraph)
  ("M-p" . backward-paragraph))
(defun nowstamp ()
  "Insert the timestamp I want"
  (interactive)
  (insert (format-time-string "%Y-%m-%dT%H:%M%Z")))
(global-set-key (kbd "C-x t") 'nowstamp)

#+end_src

** better commenting on super-/
From [[http://endlessparentheses.com/implementing-comment-line.html][endless parentheses]]. Note that it can't deal with single lines of elisp code in
=begin_src ... end_src= blocks. Regions, ok, but not single lines.
#+begin_src emacs-lisp
  (defun endless/comment-line-or-region (n)
      "Comment or uncomment current line and leave point after it.
    With positive prefix, apply to N lines including current one.
    With negative prefix, apply to -N lines above.
    If region is active, apply to active region instead."
      (interactive "p")
      (if (use-region-p)
    	  (comment-or-uncomment-region
    	   (region-beginning) (region-end))
	(let ((range
               (list (line-beginning-position)
                     (goto-char (line-end-position n)))))
	  (comment-or-uncomment-region
	   (apply #'min range)
	   (apply #'max range)))
	(back-to-indentation)))
  (bind-key (kbd "s-/") 'endless/comment-line-or-region)
#+end_src

So this is a line of text.
This is a second line.

and a third.

** minor behavior hacks
  #+begin_src emacs-lisp :eval yes
(global-set-key (kbd "C-x k") 'kill-this-buffer)
  #+end_src


* Workflow
** todo-txt
This is from [[http://todotxt.com][Gina Trapani's legendary script]]. I know that =org-mode=
loves todo's, but I find them overwhelmingly complicated. With
todotxt, I understand what I'm doing, and I can interact with the
todo.txt file from other tools outside of emacs (heresy! I know).
#+begin_src emacs-lisp
(use-package todotxt
  :init (setq todotxt-file "~/Documents/notes/todo.txt")
  :bind ("C-t" . todotxt))
#+end_src
* Little hacks
There aren't any now, but there will be.
#+begin_src emacs-lisp
;; https://github.com/jjasghar/alfred-org-capture/blob/master/el/alfred-org-capture.el
(defun make-orgcapture-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (make-frame '((name . "remember") (width . 80) (height . 16)
                (top . 400) (left . 300)
                (font . "-apple-Monaco-medium-normal-normal-*-13-*-*-*-m-0-iso10646-1")
                ))
  (select-frame-by-name "remember")
  (org-capture))
#+end_src

* Modes
** markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
  :config)
#+end_src
** magit FIXME
#+begin_src emacs-lisp
  ;; (use-package magit
  ;;   :ensure t
  ;;   :init (progn (
  ;;      (setq magit-git-executable "/usr/local/bin/git"))))

  ;; (defhydra hydra-magit (:color blue :columns 3)
  ;;   "Magit"
  ;;   ("s" magit-status "status")
  ;;   ("c" magit-commit "commit")
  ;;   ("C" magit-checkout "checkout")
  ;;   ("p" magit-
  ;;   ("v" magit-branch-manager "branch manager")
  ;;   ("m" magit-merge "merge")
  ;;   ("l" magit-log "log")
  ;;   ("!" magit-git-command "command")
  ;;   ("$" magit-process "process")))
#+end_src

* Searching, buffers, and other finding bits
** Helm and swiper

In the =use-package= spec I found, there ere a bunch of =C-x c=
sequences. Those are the kind of thing I'll never remember, so I need
to move them to hydras or delete them.
#+begin_src emacs-lisp
  (use-package helm
    :diminish helm-mode
    :init
    (progn
      (require 'helm-config)
      (setq helm-candidate-number-limit 100)
      ;; From https://gist.github.com/antifuchs/9238468
      (setq helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-yas-display-key-on-candidate t
            helm-quick-update t
            helm-M-x-requires-pattern nil
            helm-ff-skip-boring-files t)
      (helm-mode))
    :bind (("C-c h" . helm-mini)
           ("C-h a" . helm-apropos)
           ("C-x C-b" . helm-buffers-list)
           ("C-x b" . helm-buffers-list)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ;; ("C-x c o" . helm-occur)
           ;; ("C-x c s" . helm-swoop)
           ;; ("C-x c y" . helm-yas-complete)
           ;; ("C-x c Y" . helm-yas-create-snippet-on-region)
           ;; ("C-x c b" . my/helm-do-grep-book-notes)
           ("C-x c SPC" . helm-all-mark-rings)))
  (ido-mode -1) ;; Turn off ido mode in case I enabled it accidentally

  (use-package swiper-helm
    :config
    :bind (("C-s" . swiper-helm)
	   ("C-r" . swiper-helm)))

  (use-package helm-swoop)  ;; on hydra
  #+end_src


* Editing
** multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors)
(global-set-key (kbd "C-c m c") 'mc/edit-lines)
#+end_src
** yank pop w hydra
#+begin_src emacs-lisp
(defhydra hydra-yank-pop ()
  "yank"
  ("C-y" yank nil)
  ("M-y" yank-pop nil)
  ("y" (yank-pop 1) "next")
  ("Y" (yank-pop -1) "prev")
  ("l" helm-show-kill-ring "list" :color blue)
  ("u" undo-tree-visualize "undoTree"))
(bind-key* (kbd "M-y") #'hydra-yank-pop/yank-pop)
(bind-key* (kbd "C-y") #'hydra-yank-pop/yank)
  #+end_src

** M-p, M-n
The question here is what these do. I think backward-paragraph?
** flyspell
  #+begin_src emacs-lisp
(use-package flyspell
  :init
  (progn
    (add-hook 'text-mode-hook 'flyspell-mode)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
  :config
  (setq ispell-extra-args '("--sug-mode=bad-spellers")
        ispell-personal-dictionary "~/.flydict"
	ispell-program-name (executable-find "aspell")
	ispell-extra-args
	(list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
        "--lang=en_US"
        "--ignore=3"))
   :bind* ("C-;" . flyspell-auto-correct-previous-word))
(add-hook 'org-mode-hook 'turn-on-flyspell)

  #+end_src

** Autocomplete with =company-mode=
  #+begin_src emacs-lisp
(use-package company
  :ensure t
  :defer t
  :config (global-company-mode))
  #+end_src

** snippets hydra **TODO**

* Navigation

** A better =C-a= from [[https://github.com/bbatsov/crux/blob/master/crux.el][=crux=]]
  #+begin_src emacs-lisp
(use-package crux
  :bind* ("C-a" . crux-move-beginning-of-line))
  #+end_src

** Dragging stuff w =super-up,down=
This means that M-up|down|right|left drag line or the region.
  #+begin_src emacs-lisp
(use-package drag-stuff
  :diminish ""
  :config
    (drag-stuff-global-mode 1)
  :bind* (
    ([(super up)] . drag-stuff-up)
    ([(super down)] . drag-stuff-down)))
  #+end_src

  #+RESULTS:

** =ace= and =avy= window jumping
  #+begin_src emacs-lisp
(use-package ace-window
  :ensure t
  :init
  (progn
    (global-set-key [remap other-window] 'ace-window)
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0)))))
    )
  :bind* ("C-'" . ace-window)
  :config (progn (setq
		  aw-keys '(?f ?g ?h ?j ?k ?l)
		  aw-background nil)))
(use-package avy
  :config (setq avy-all-windows 'all-frames))
  #+end_src


** TODO window and frame stuff (on yy)y
#+begin_src emacs-lisp
(defhydra my/window-movement (:color blue
				     :hint nil)
"
^Jump^         ^Files^       ^Buffer^     ^Search
------------------------------------------------------
_y_: other    _m_: buf-rec   _b_: buff    _s_: swoop
_a_: ace-win  _r_: recent    _B_: ibuff   _S_: multswoop
_c_: char     _F_: find-oth  _r_: rename  _g_: grep
_l_: line     _f_: find      _D_: del(win)
"
  ("y" other-window)
  ("a" ace-window)
  ("c" avy-goto-char)
  ("l" avy-goto-line)
  ("f" helm-find-files)
  ("r" helm-recentf)
  ("m" helm-mini)
  ("F" helm-find-files)
  ("D" ace-delete-window)
  ("b" helm-buffers-list)
  ("B" ibuffer)
  ("r" crux-rename-file-and-buffer)
  ("s" helm-swoop)
  ("S" helm-multi-swoop-all)
  ("g" helm-grep-do-grep)
  ("q" quit-window "quit" :color blue))
#+end_src

** TODO personal hydras (on hh)

* key chords
  the ones we want are definitely in there (uu = undo; jj/jl = avy goto char/line; hh = my personal stuff, prob mostly org-mode; ff = file & buffer; yy = _window_ movements; xx = snippets).

  note that all of the key-chord hydras should include (i) insert and (q). Columns should get us there but think about the headers. also none should include a head w the char in the chord. that way 3 presses of the chord key dump it out.

  oo, org-mode: close/open at 1/2/3 levels;

  yy: windmove, new frame, ace-win, find files, recent, mini, grep??

  xx: hippie-expand; and some snippets

  hh: crux-duplicate-current-line-or-region; crux-kill-line-backwards;
  switch to or open a few freq files (init.org, .bash_profile, log,
  todo); single-step org todo capture; org-todo-overview look.

** chord assignments
  #+begin_src emacs-lisp
(use-package key-chord
  :init
  (progn
    (setq key-chord-one-key-delay 0.2)
    (key-chord-mode 1)
    (key-chord-define-global "uu"     'undo)
    (key-chord-define-global "jj"     'avy-goto-char)
    (key-chord-define-global "jl"     'avy-goto-line)
    (key-chord-define-global "gg"     'hydra-magit/body)
    (key-chord-define-global "xx"     'er/expand-region)  ;; TBD!
    (key-chord-define-global "hh"     'my/key-chord-commands/body) ;; TBD!
    (key-chord-define-global "yy"     'my/window-movement/body)))
  #+end_src


* Conclusion
** seek to open window w buffer switch
** set modeline
  Someday this could be smart modeline, but it's not now. Note that it
  has to load *after* =elscreen=, else they conflict.
  #+begin_src emacs-lisp
  (load-file "~/dotfiles/emacs/modeline.el")
  #+end_src

** stuff to consider [/]
 - [ ] elpy
 - [ ] autosave
 - [ ] one-on-one emacs: no more windows.

** stuff to keep working on [/]
 - [ ] flyspell's autocorrect rarely gets it right the first time.
 - [ ] kill other window, the annoying help or error window that just popped up.
 - [ ] fill-column-indicator not working

This file was last evaluated on #{Date.today}
# end.
